# -*- coding: utf-8 -*-
"""modelagem_preditiva_ia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13zNzAJo5m_iYMSCvJjxUmf9RcbDYdcWF

# Origem dos Dados - Residuos Sólidos Urbanos

Os dados utilizados foram obtidos no portal da Prefeitura de São Paulo, no endereço:
http://dados.prefeitura.sp.gov.br/it/dataset/coleta-de-residuos-solidos-urbanos, abrangendo os anos de 2013 a 2020.

Foi realizado um pré-processamento dos datasets, que contêm informações sobre a quantidade total de resíduos sólidos urbanos coletados — tanto no geral quanto por tipo de resíduo — expressa em toneladas. A coleta foi realizada por empresas e concessionárias integrantes do Sistema de Limpeza Urbana do município de São Paulo durante o período citado.
"""

import pandas as pd
import re
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""## 1.   Pré-processamento de dados

### Ano de 2013

#### Leitura e entendimento dos dados
"""

df_2013 = pd.read_csv("amlurbcoletatiposresiduos2013.csv", encoding="latin1", sep=';')

print("\n\nNome das colunas do dataset de 2013:\n\n")
print(df_2013.columns)

print("\n\nTamanho (linhas, colunas) do dataset de 2013:\n\n")
print(df_2013.shape)

print("\n\nConteúdo das 21 linhas do dataset de 2013:\n\n")
print(df_2013.head(21))

"""#### Limpeza de dados"""

# Renomeação da coluna com caractere especial
df_2013.rename(columns={'TIPO DE RESÖDUO': 'TIPO DE RESIDUO'}, inplace=True)

# Remoção das linhas com "TOTAL" ou "VAZIO"
df_2013 = df_2013[df_2013['TIPO DE RESIDUO'].notna()]
df_2013 = df_2013[df_2013['TIPO DE RESIDUO'].str.upper() != 'TOTAL']
df_2013 = df_2013[df_2013['TIPO DE RESIDUO'].str.upper() != '(VAZIO)']

# Remoção da coluna com "TOTAL"
del df_2013['TOTAL 2013']

print(df_2013.columns)

"""#### Transformação de dados"""

padrao_mes_ano = re.compile(r'^[a-zA-Z]{3}/\d{2}$')
colunas_mes_ano = [col for col in df_2013.columns if padrao_mes_ano.match(col.lower())]

# Conversão de valores para número
for col in colunas_mes_ano:
    df_2013[col] = df_2013[col].str.replace('.', '', regex=False)
    df_2013[col] = df_2013[col].str.replace(',', '.', regex=False)
    df_2013[col] = pd.to_numeric(df_2013[col], errors='coerce')

# Conversão para formato longo
df_2013_long = df_2013.melt(id_vars='TIPO DE RESIDUO', value_vars=colunas_mes_ano,
                  var_name='MES_ANO', value_name='TONELADAS')

# Dicionário de tradução (inglês para português)
meses_en_pt = {
    'jan': 'jan', 'feb': 'fev', 'mar': 'mar', 'apr': 'abr',
    'may': 'mai', 'jun': 'jun', 'jul': 'jul', 'aug': 'ago',
    'sep': 'set', 'oct': 'out', 'nov': 'nov', 'dec': 'dez'
}

# Tradução e separação das datas
df_2013_long['MES_ANO'] = df_2013_long['MES_ANO'].str.lower().replace(meses_en_pt, regex=True)

# Criação das colunas 'MES' e 'ANO'
df_2013_long['MES'] = df_2013_long['MES_ANO'].str.split('/').str[0]
df_2013_long['ANO'] = '20' + df_2013_long['MES_ANO'].str.split('/').str[1] # Adiciona '20' para o século

# Remove a coluna 'MES_ANO' original
df_2013_long.drop('MES_ANO', axis=1, inplace=True)

print(df_2013_long.head())

"""#### Exportação para uso posterior"""

df_2013_long.to_csv('residuos_2013_transformado.csv', index=False)
df_2013_long.head(5)

"""### Ano de 2014

#### Leitura e entendimento dos dados
"""

df_2014 = pd.read_csv("amlurbcoletatiposresiduos2014.csv", encoding="latin1", sep=';')

print("\n\nNome das colunas do dataset de 2014:\n\n")
print(df_2014.columns)

print("\n\nTamanho (linhas, colunas) do dataset de 2014:\n\n")
print(df_2014.shape)

print("\n\nConteúdo das 19 linhas do dataset de 2014:\n\n")
print(df_2014.head(19))

"""#### Limpeza de dados"""

# Renomeação da coluna com caractere especial
df_2014.rename(columns={'TIPO DE RESÖDUO': 'TIPO DE RESIDUO'}, inplace=True)

# Remoção das linhas com "TOTAL" ou "VAZIO"
df_2014 = df_2014[df_2014['TIPO DE RESIDUO'].notna()]
df_2014 = df_2014[df_2014['TIPO DE RESIDUO'].str.upper() != 'TOTAL']
df_2014 = df_2014[df_2014['TIPO DE RESIDUO'].str.upper() != '(VAZIO)']

# Remoção da coluna com "TOTAL"
del df_2014['TOTAL 2014']

print(df_2014.columns)

"""#### Transformação de dados"""

padrao_mes_ano = re.compile(r'^[a-zA-Z]{3}/\d{2}$')
colunas_mes_ano = [col for col in df_2014.columns if padrao_mes_ano.match(col.lower())]

# Conversão de valores para número
for col in colunas_mes_ano:
    df_2014[col] = df_2014[col].str.replace('.', '', regex=False)
    df_2014[col] = df_2014[col].str.replace(',', '.', regex=False)
    df_2014[col] = pd.to_numeric(df_2014[col], errors='coerce')

# Conversão para formato longo
df_2014_long = df_2014.melt(id_vars='TIPO DE RESIDUO', value_vars=colunas_mes_ano,
                  var_name='MES_ANO', value_name='TONELADAS')

# Dicionário de tradução (inglês para português)
meses_en_pt = {
    'jan': 'jan', 'feb': 'fev', 'mar': 'mar', 'apr': 'abr',
    'may': 'mai', 'jun': 'jun', 'jul': 'jul', 'aug': 'ago',
    'sep': 'set', 'oct': 'out', 'nov': 'nov', 'dec': 'dez'
}

# Tradução e separação das datas
df_2014_long['MES_ANO'] = df_2014_long['MES_ANO'].str.lower().replace(meses_en_pt, regex=True)

# Criação das colunas 'MES' e 'ANO'
df_2014_long['MES'] = df_2014_long['MES_ANO'].str.split('/').str[0]
df_2014_long['ANO'] = '20' + df_2014_long['MES_ANO'].str.split('/').str[1] # Adiciona '20' para o século

# Remove a coluna 'MES_ANO' original
df_2014_long.drop('MES_ANO', axis=1, inplace=True)

print(df_2014_long.head())

"""#### Exportação para uso posterior"""

df_2014_long.to_csv('residuos_2014_transformado.csv', index=False)
df_2014_long.head(5)

"""### Ano de 2015

#### Leitura e entendimento dos dados
"""

df_2015 = pd.read_csv("amlurbcoletatiposresiduos2015.csv", encoding="latin1", sep=';')

print("\n\nNome das colunas do dataset de 2015:\n\n")
print(df_2015.columns)

print("\n\nTamanho (linhas, colunas) do dataset de 2015:\n\n")
print(df_2015.shape)

print("\n\nConteúdo das 21 linhas do dataset de 2015:\n\n")
print(df_2015.head(21))

"""#### Limpeza de dados"""

# Renomeação da coluna com caractere especial
df_2015.rename(columns={'TIPO DE RESÍDUO': 'TIPO DE RESIDUO'}, inplace=True)

# Remoção das linhas com "TOTAL" ou "VAZIO"
df_2015 = df_2015[df_2015['TIPO DE RESIDUO'].notna()]
df_2015 = df_2015[df_2015['TIPO DE RESIDUO'].str.upper() != 'TOTAL']
df_2015 = df_2015[df_2015['TIPO DE RESIDUO'].str.upper() != '(VAZIO)']

# Remoção da coluna com "TOTAL"
del df_2015['TOTAL 2015']

print(df_2015.columns)

"""#### Transformação de dados"""

padrao_mes_ano = re.compile(r'^[a-zA-Z]{3}/\d{2}$')
colunas_mes_ano = [col for col in df_2015.columns if padrao_mes_ano.match(col.lower())]

# Conversão de valores para número
for col in colunas_mes_ano:
    df_2015[col] = df_2015[col].str.replace('.', '', regex=False)
    df_2015[col] = df_2015[col].str.replace(',', '.', regex=False)
    df_2015[col] = pd.to_numeric(df_2015[col], errors='coerce')

# Conversão para formato longo
df_2015_long = df_2015.melt(id_vars='TIPO DE RESIDUO', value_vars=colunas_mes_ano,
                  var_name='MES_ANO', value_name='TONELADAS')

# Dicionário de tradução (inglês para português)
meses_en_pt = {
    'jan': 'jan', 'feb': 'fev', 'mar': 'mar', 'apr': 'abr',
    'may': 'mai', 'jun': 'jun', 'jul': 'jul', 'aug': 'ago',
    'sep': 'set', 'oct': 'out', 'nov': 'nov', 'dec': 'dez'
}

# Tradução e separação das datas
df_2015_long['MES_ANO'] = df_2015_long['MES_ANO'].str.lower().replace(meses_en_pt, regex=True)

# Criação das colunas 'MES' e 'ANO'
df_2015_long['MES'] = df_2015_long['MES_ANO'].str.split('/').str[0]
df_2015_long['ANO'] = '20' + df_2015_long['MES_ANO'].str.split('/').str[1] # Adiciona '20' para o século

# Remove a coluna 'MES_ANO' original
df_2015_long.drop('MES_ANO', axis=1, inplace=True)

print(df_2015_long.head())

"""#### Exportação para uso posterior"""

df_2015_long.to_csv('residuos_2015_transformado.csv', index=False)
df_2015_long.head(5)

"""### Ano de 2016

#### Leitura e entendimento dos dados
"""

df_2016 = pd.read_csv("amlurbcoletatiposresiduos2016.csv", encoding="latin1", sep=';')

print("\n\nNome das colunas do dataset de 2016:\n\n")
print(df_2016.columns)

print("\n\nTamanho (linhas, colunas) do dataset de 2016:\n\n")
print(df_2016.shape)

print("\n\nConteúdo das 24 linhas do dataset de 2016:\n\n")
print(df_2016.head(24))

"""#### Limpeza de dados"""

# Renomeação da coluna com caractere especial
df_2016.rename(columns={'TIPO DE RESÍDUO': 'TIPO DE RESIDUO'}, inplace=True)

# Remoção das linhas com "TOTAL" ou "VAZIO"
df_2016 = df_2016[df_2016['TIPO DE RESIDUO'].notna()]
df_2016 = df_2016[df_2016['TIPO DE RESIDUO'].str.upper() != 'TOTAL']
df_2016 = df_2016[df_2016['TIPO DE RESIDUO'].str.upper() != '(VAZIO)']

# Remoção da coluna com "TOTAL"
del df_2016['TOTAL 2016']

print(df_2016.columns)

"""#### Transformação de dados"""

padrao_mes_ano = re.compile(r'^[a-zA-Z]{3}/\d{2}$')
colunas_mes_ano = [col for col in df_2016.columns if padrao_mes_ano.match(col.lower())]

# Conversão de valores para número
for col in colunas_mes_ano:
    df_2016[col] = df_2016[col].str.replace('.', '', regex=False)
    df_2016[col] = df_2016[col].str.replace(',', '.', regex=False)
    df_2016[col] = pd.to_numeric(df_2016[col], errors='coerce')

# Conversão para formato longo
df_2016_long = df_2016.melt(id_vars='TIPO DE RESIDUO', value_vars=colunas_mes_ano,
                  var_name='MES_ANO', value_name='TONELADAS')

# Dicionário de tradução (inglês para português)
meses_en_pt = {
    'jan': 'jan', 'feb': 'fev', 'mar': 'mar', 'apr': 'abr',
    'may': 'mai', 'jun': 'jun', 'jul': 'jul', 'aug': 'ago',
    'sep': 'set', 'oct': 'out', 'nov': 'nov', 'dec': 'dez'
}

# Tradução e separação das datas
df_2016_long['MES_ANO'] = df_2016_long['MES_ANO'].str.lower().replace(meses_en_pt, regex=True)

# Criação das colunas 'MES' e 'ANO'
df_2016_long['MES'] = df_2016_long['MES_ANO'].str.split('/').str[0]
df_2016_long['ANO'] = '20' + df_2016_long['MES_ANO'].str.split('/').str[1] # Adiciona '20' para o século

# Remove a coluna 'MES_ANO' original
df_2016_long.drop('MES_ANO', axis=1, inplace=True)

print(df_2016_long.head())

"""#### Exportação para uso posterior"""

df_2016_long.to_csv('residuos_2016_transformado.csv', index=False)
df_2016_long.head(5)

"""### Ano de 2017

#### Leitura e entendimento dos dados
"""

df_2017 = pd.read_csv("amlurbcoletatiposresiduos2017.csv", encoding="latin1", sep=';')

print("\n\nNome das colunas do dataset de 2017:\n\n")
print(df_2017.columns)

print("\n\nTamanho (linhas, colunas) do dataset de 2017:\n\n")
print(df_2017.shape)

print("\n\nConteúdo das 23 linhas do dataset de 2017:\n\n")
print(df_2017.head(23))

"""#### Limpeza de dados"""

# Renomeação da coluna com caractere especial
df_2017.rename(columns={'TIPO DE RESÍDUO': 'TIPO DE RESIDUO'}, inplace=True)

# Remoção das linhas com "TOTAL" ou "VAZIO"
df_2017 = df_2017[df_2017['TIPO DE RESIDUO'].notna()]
df_2017 = df_2017[df_2017['TIPO DE RESIDUO'].str.upper() != 'TOTAL']
df_2017 = df_2017[df_2017['TIPO DE RESIDUO'].str.upper() != '(VAZIO)']

# Remoção da coluna com "TOTAL"
del df_2017['TOTAL 2017']

print(df_2017.columns)

"""#### Transformação de dados"""

padrao_mes_ano = re.compile(r'^[a-zA-Z]{3}/\d{2}$')
colunas_mes_ano = [col for col in df_2017.columns if padrao_mes_ano.match(col.lower())]

# Conversão de valores para número
for col in colunas_mes_ano:
    df_2017[col] = df_2017[col].str.replace('.', '', regex=False)
    df_2017[col] = df_2017[col].str.replace(',', '.', regex=False)
    df_2017[col] = pd.to_numeric(df_2017[col], errors='coerce')

# Conversão para formato longo
df_2017_long = df_2017.melt(id_vars='TIPO DE RESIDUO', value_vars=colunas_mes_ano,
                  var_name='MES_ANO', value_name='TONELADAS')

# Dicionário de tradução (inglês para português)
meses_en_pt = {
    'jan': 'jan', 'feb': 'fev', 'mar': 'mar', 'apr': 'abr',
    'may': 'mai', 'jun': 'jun', 'jul': 'jul', 'aug': 'ago',
    'sep': 'set', 'oct': 'out', 'nov': 'nov', 'dec': 'dez'
}

# Tradução e separação das datas
df_2017_long['MES_ANO'] = df_2017_long['MES_ANO'].str.lower().replace(meses_en_pt, regex=True)

# Criação das colunas 'MES' e 'ANO'
df_2017_long['MES'] = df_2017_long['MES_ANO'].str.split('/').str[0]
df_2017_long['ANO'] = '20' + df_2017_long['MES_ANO'].str.split('/').str[1] # Adiciona '20' para o século

# Remove a coluna 'MES_ANO' original
df_2017_long.drop('MES_ANO', axis=1, inplace=True)

print(df_2017_long.head())

"""#### Exportação para uso posterior"""

df_2017_long.to_csv('residuos_2017_transformado.csv', index=False)
df_2017_long.head(5)

"""### Ano de 2018

#### Leitura e entendimento dos dados
"""

df_2018 = pd.read_csv("amlurbcoletatiposresiduos2018.csv", encoding="latin1", sep=';')

print("\n\nNome das colunas do dataset de 2018:\n\n")
print(df_2018.columns)

print("\n\nTamanho (linhas, colunas) do dataset de 2018:\n\n")
print(df_2018.shape)

print("\n\nConteúdo das 22 linhas do dataset de 2018:\n\n")
print(df_2018.head(22))

"""#### Limpeza de dados"""

# Renomeação da coluna com caractere especial
df_2018.rename(columns={'TIPO DE RESÍDUO': 'TIPO DE RESIDUO'}, inplace=True)

# Remoção das linhas com "TOTAL" ou "VAZIO"
df_2018 = df_2018[df_2018['TIPO DE RESIDUO'].notna()]
df_2018 = df_2018[df_2018['TIPO DE RESIDUO'].str.upper() != 'TOTAL']
df_2018 = df_2018[df_2018['TIPO DE RESIDUO'].str.upper() != '(VAZIO)']

# Remoção da coluna com "TOTAL"
del df_2018['TOTAL 2018']

print(df_2018.columns)

"""#### Transformação de dados"""

padrao_mes_ano = re.compile(r'^[a-zA-Z]{3}/\d{2}$')
colunas_mes_ano = [col for col in df_2018.columns if padrao_mes_ano.match(col.lower())]

# Conversão de valores para número
for col in colunas_mes_ano:
    df_2018[col] = df_2018[col].str.replace('.', '', regex=False)
    df_2018[col] = df_2018[col].str.replace(',', '.', regex=False)
    df_2018[col] = pd.to_numeric(df_2018[col], errors='coerce')

# Conversão para formato longo
df_2018_long = df_2018.melt(id_vars='TIPO DE RESIDUO', value_vars=colunas_mes_ano,
                  var_name='MES_ANO', value_name='TONELADAS')

# Dicionário de tradução (inglês para português)
meses_en_pt = {
    'jan': 'jan', 'feb': 'fev', 'mar': 'mar', 'apr': 'abr',
    'may': 'mai', 'jun': 'jun', 'jul': 'jul', 'aug': 'ago',
    'sep': 'set', 'oct': 'out', 'nov': 'nov', 'dec': 'dez'
}

# Tradução e separação das datas
df_2018_long['MES_ANO'] = df_2018_long['MES_ANO'].str.lower().replace(meses_en_pt, regex=True)

# Criação das colunas 'MES' e 'ANO'
df_2018_long['MES'] = df_2018_long['MES_ANO'].str.split('/').str[0]
df_2018_long['ANO'] = '20' + df_2018_long['MES_ANO'].str.split('/').str[1] # Adiciona '20' para o século

# Remove a coluna 'MES_ANO' original
df_2018_long.drop('MES_ANO', axis=1, inplace=True)

print(df_2018_long.head())

"""#### Exportação para uso posterior"""

df_2018_long.to_csv('residuos_2018_transformado.csv', index=False)
df_2018_long.head(5)

"""### Ano de 2019

#### Leitura e entendimento dos dados
"""

df_2019 = pd.read_csv("amlurbcoletatiposresiduos2019.csv", encoding="latin1", sep=';')

print("\n\nNome das colunas do dataset de 2019:\n\n")
print(df_2019.columns)

print("\n\nTamanho (linhas, colunas) do dataset de 2019:\n\n")
print(df_2019.shape)

print("\n\nConteúdo das 30 linhas do dataset de 2019:\n\n")
print(df_2019.head(30))

"""#### Limpeza de dados"""

# Renomeação da coluna com caractere especial
df_2019.rename(columns={'Tipo de resíduo - Toneladas': 'TIPO DE RESIDUO'}, inplace=True)

# Remover a linha de "Total geral" e a linha descritiva
df_2019 = df_2019[~df_2019['TIPO DE RESIDUO'].str.contains('Total geral', case=False, na=False)]
df_2019 = df_2019[~df_2019['TIPO DE RESIDUO'].str.contains('Desconsiderando', case=False, na=False)]

# Processar as colunas de toneladas
for col in df_2019.columns[1:]:
    # Converter para string para garantir que as operações de string funcionem
    df_2019[col] = df_2019[col].astype(str)

    # Substituir '-' por '0'
    df_2019[col] = df_2019[col].replace(' -   ', '0')
    df_2019[col] = df_2019[col].replace('-', '0')

    # Substituir vírgula por ponto
    df_2019[col] = df_2019[col].str.replace(',', '.', regex=False)

    # Converter 'nan' (string) para NaN (numpy.nan) para tratamento de valores ausentes
    df_2019[col] = df_2019[col].replace('nan', np.nan)

    # Converter para numérico (float)
    df_2019[col] = pd.to_numeric(df_2019[col], errors='coerce')

print(df_2019.head(30))
print(df_2019.dtypes)

"""#### Transformação de dados"""

padrao_mes_ano = re.compile(r'^[a-zA-Z]{3}/\d{2}$')
colunas_mes_ano = [col for col in df_2019.columns if padrao_mes_ano.match(col.lower())]

# Conversão de valores para número
for col in colunas_mes_ano:
    df_2019[col] = pd.to_numeric(df_2019[col], errors='coerce')

# Conversão para formato longo
df_2019_long = df_2019.melt(id_vars='TIPO DE RESIDUO', value_vars=colunas_mes_ano,
                  var_name='MES_ANO', value_name='TONELADAS')

# Dicionário de tradução (inglês para português)
meses_en_pt = {
    'jan': 'jan', 'feb': 'fev', 'mar': 'mar', 'apr': 'abr',
    'may': 'mai', 'jun': 'jun', 'jul': 'jul', 'aug': 'ago',
    'sep': 'set', 'oct': 'out', 'nov': 'nov', 'dec': 'dez'
}

# Tradução e separação das datas
df_2019_long['MES_ANO'] = df_2019_long['MES_ANO'].str.lower().replace(meses_en_pt, regex=True)

# Criação das colunas 'MES' e 'ANO'
df_2019_long['MES'] = df_2019_long['MES_ANO'].str.split('/').str[0]
df_2019_long['ANO'] = '20' + df_2019_long['MES_ANO'].str.split('/').str[1] # Adiciona '20' para o século

# Remove a coluna 'MES_ANO' original
df_2019_long.drop('MES_ANO', axis=1, inplace=True)

print(df_2019_long.head())

"""#### Exportação para uso posterior"""

df_2019_long.to_csv('residuos_2019_transformado.csv', index=False)
df_2019_long.head(5)

"""### Ano de 2020

#### Leitura e entendimento dos dados
"""

df_2020 = pd.read_csv("residuos-2020-ate-dezembro.csv", encoding="latin1", sep=';')

print("\n\nNome das colunas do dataset de 2020:\n\n")
print(df_2020.columns)

print("\n\nTamanho (linhas, colunas) do dataset de 2020:\n\n")
print(df_2020.shape)

print("\n\nConteúdo das 22 linhas do dataset de 2020:\n\n")
print(df_2020.head(33))

"""#### Limpeza de dados"""

# Renomeação da coluna com caractere especial
df_2020.rename(columns={'Tipo de resíduo - Toneladas': 'TIPO DE RESIDUO'}, inplace=True)

# Remoção das linhas com "Total geral"
df_2020 = df_2020[~df_2020['TIPO DE RESIDUO'].str.contains('Total geral', case=False, na=False)]

print(df_2020.columns)

"""#### Transformação de dados"""

padrao_mes_ano = re.compile(r'^[a-zA-Z]{3}/\d{2}$')
colunas_mes_ano = [col for col in df_2020.columns if padrao_mes_ano.match(col.lower())]

# Conversão de valores para número
for col in colunas_mes_ano:
    df_2020[col] = pd.to_numeric(df_2020[col], errors='coerce')

# Conversão para formato longo
df_2020_long = df_2020.melt(id_vars='TIPO DE RESIDUO', value_vars=colunas_mes_ano,
                  var_name='MES_ANO', value_name='TONELADAS')

# Dicionário de tradução (inglês para português)
meses_en_pt = {
    'jan': 'jan', 'feb': 'fev', 'mar': 'mar', 'apr': 'abr',
    'may': 'mai', 'jun': 'jun', 'jul': 'jul', 'aug': 'ago',
    'sep': 'set', 'oct': 'out', 'nov': 'nov', 'dec': 'dez'
}

# Tradução e separação das datas
df_2020_long['MES_ANO'] = df_2020_long['MES_ANO'].str.lower().replace(meses_en_pt, regex=True)

# Criação das colunas 'MES' e 'ANO'
df_2020_long['MES'] = df_2020_long['MES_ANO'].str.split('/').str[0]
df_2020_long['ANO'] = '20' + df_2020_long['MES_ANO'].str.split('/').str[1] # Adiciona '20' para o século

# Remove a coluna 'MES_ANO' original
df_2020_long.drop('MES_ANO', axis=1, inplace=True)

print(df_2020_long.head())

"""#### Exportação para uso posterior"""

df_2020_long.to_csv('residuos_2020_transformado.csv', index=False)
df_2020_long.head(5)

"""## 2. Unificação dos dataframes"""

dfs_padronizados = [df_2013_long, df_2014_long, df_2015_long, df_2016_long, df_2017_long, df_2018_long]
df_2013_2018 = pd.concat(dfs_padronizados, ignore_index=True)

print("\n\nNome das colunas do dataset de 2013 a 2018:\n\n")
print(df_2013_2018.columns)

print("\n\nTamanho (linhas, colunas) do dataset de 2013 a 2018:\n\n")
print(df_2013_2018.shape)

print("\n\nConteúdo das 20 linhas do dataset de 2013 a 2018:\n\n")
print(df_2013_2018.head(20))

df_2013_2018.to_csv('residuos_2013_2018_unificado.csv', index=False)

"""## 3. Análise Exploratória"""

print("\n\nInformações gerais do dataset:\n\n")
df_2013_2018.info()

print("\n\nEstatísticas descritivas das colunas numéricas:\n\n")
print(df_2013_2018.describe())

print("\n\nEstatísticas descritivas das colunas categóricas:\n\n")
print(df_2013_2018.describe(include='object'))

print("\n\nValores únicos na coluna 'TIPO DE RESIDUO':\n\n")
print(df_2013_2018['TIPO DE RESIDUO'].unique())

print("\n\nValores únicos na coluna 'MES':\n\n")
print(df_2013_2018['MES'].unique())

print("\n\nValores únicos na coluna 'ANO':\n\n")
print(df_2013_2018['ANO'].unique())

print("\n\nNúmero de valores únicos na coluna 'TIPO DE RESIDUO':\n\n")
print(df_2013_2018['TIPO DE RESIDUO'].nunique())

print("\n\nContagem de valores na coluna 'TIPO DE RESIDUO':\n\n")
print(df_2013_2018['TIPO DE RESIDUO'].value_counts())

print("\n\nProporção de valores na coluna 'TIPO DE RESIDUO':\n\n")
print(df_2013_2018['TIPO DE RESIDUO'].value_counts(normalize=True))

print("\n\nNúmero de valores nulos por coluna:\n\n")
print(df_2013_2018.isnull().sum())

print("\n\nProporção de valores nulos por coluna:\n\n")
print(df_2013_2018.isnull().mean())

"""## 4. Visualizações

### Histograma da Distribuição de Toneladas
"""

plt.figure(figsize=(10, 6))
sns.histplot(df_2013_2018['TONELADAS'], kde=True)
plt.title('Distribuição de Toneladas')
plt.xlabel('Toneladas')
plt.ylabel('Frequência')
plt.show()

"""### Gráfico de Barras para comparar a frequência de diferentes tipos de resíduos"""

plt.figure(figsize=(12, 6))
sns.barplot(x=df_2013_2018['TIPO DE RESIDUO'].value_counts().index,
            y=df_2013_2018['TIPO DE RESIDUO'].value_counts().values)
plt.title('Contagem por Tipo de Resíduo')
plt.xlabel('Tipo de Resíduo')
plt.ylabel('Contagem')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""### Gráfico de Linha para visualizar tendências ao longo do tempo"""

df_tendencia = df_2013_2018.groupby(['ANO', 'MES'])['TONELADAS'].sum().reset_index()

plt.figure(figsize=(15, 6))
sns.lineplot(data=df_tendencia, x='MES', y='TONELADAS', hue='ANO')
plt.title('Tendência de Toneladas ao Longo do Tempo')
plt.xlabel('Mês')
plt.ylabel('Total de Toneladas')
plt.show()

"""### Box Plots para identificar outliers e visualizar a distribuição de dados numéricos por tipo de resíduo"""

plt.figure(figsize=(12, 6))
sns.boxplot(x='TIPO DE RESIDUO', y='TONELADAS', data=df_2013_2018)
plt.title('Distribuição de Toneladas por Tipo de Resíduo')
plt.xlabel('Tipo de Resíduo')
plt.ylabel('Toneladas')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""# Origem dos Dados - Censo São Paulo

Estimativa da população residente nos municípios do Estado de São Paulo (considerando as estatísticas vitais e o Censo de 2022) ─ 2000 a 2023
https://repositorio.seade.gov.br/group/seade-populacao

## 1.   Pré-processamento de dados

### Leitura e entendimento dos dados
"""

df_estimativa_pop_idade_sexo_esp = pd.read_csv("estimativa_pop_idade_sexo_esp.csv", encoding="latin1", sep=';')

print("\n\nNome das colunas do dataset de estimativa populacional:\n\n")
print(df_estimativa_pop_idade_sexo_esp.columns)

print("\n\nTamanho (linhas, colunas) do estimativa populacional:\n\n")
print(df_estimativa_pop_idade_sexo_esp.shape)

print("\n\nConteúdo das 10 linhas do estimativa populacional:\n\n")
print(df_estimativa_pop_idade_sexo_esp.head(10))

"""## 2. Análise Exploratória"""

print("\n\nInformações gerais do dataset:\n\n")
df_estimativa_pop_idade_sexo_esp.info()

print("\n\nEstatísticas descritivas das colunas numéricas:\n\n")
print(df_estimativa_pop_idade_sexo_esp.describe())

print("\n\nEstatísticas descritivas das colunas categóricas:\n\n")
print(df_estimativa_pop_idade_sexo_esp.describe(include='object'))

print("\n\nValores únicos na coluna 'ano':\n\n")
print(df_estimativa_pop_idade_sexo_esp['ano'].unique())

print("\n\nValores únicos na coluna 'nome_mun':\n\n")
print(df_estimativa_pop_idade_sexo_esp['nome_mun'].unique())

print("\n\nValores únicos na coluna 'sexo':\n\n")
print(df_estimativa_pop_idade_sexo_esp['sexo'].unique())

print("\n\nValores únicos na coluna 'idade':\n\n")
print(df_estimativa_pop_idade_sexo_esp['idade'].unique())

print("\n\nValores únicos na coluna 'populacao':\n\n")
print(df_estimativa_pop_idade_sexo_esp['populacao'].unique())

print("\n\nNúmero de valores únicos na coluna 'nome_mun':\n\n")
print(df_estimativa_pop_idade_sexo_esp['nome_mun'].nunique())

print("\n\nContagem de valores na coluna 'nome_mun':\n\n")
print(df_estimativa_pop_idade_sexo_esp['nome_mun'].value_counts())

print("\n\nNúmero de valores nulos por coluna:\n\n")
print(df_estimativa_pop_idade_sexo_esp.isnull().sum())

print("\n\nProporção de valores nulos por coluna:\n\n")
print(df_estimativa_pop_idade_sexo_esp.isnull().mean())

"""## 3. Filtro para o município de São Paulo"""

df_sp_pop = df_estimativa_pop_idade_sexo_esp[df_estimativa_pop_idade_sexo_esp['nome_mun'] == 'São Paulo'].copy()

print("\n\nTamanho do dataset de estimativa populacional para São Paulo:\n\n")
print(df_sp_pop.shape)

print("\n\nConteúdo das 10 primeiras linhas para São Paulo:\n\n")
print(df_sp_pop.head(10))

# Período de tempo abrangido pelas estimativas populacionais para São Paulo
df_sp_pop['ano'] = df_sp_pop['ano'].astype(int)
print(df_sp_pop)

# Obtenção da estimativa da população total por ano
df_pop_anual_sp = df_sp_pop.groupby('ano')['populacao'].sum().reset_index()
df_pop_anual_sp.rename(columns={'populacao': 'populacao_total'}, inplace=True)

print("\n\nEstimativa da população total anual para São Paulo:\n\n")

print(df_pop_anual_sp)

"""## 4. Normalização de Dados"""

# Conversão para o tipo inteiro em ambos os dataframes
df_2013_2018['ANO'] = df_2013_2018['ANO'].astype(int)
df_pop_anual_sp['ano'] = df_pop_anual_sp['ano'].astype(int)

# Agrupamento do df_2013_2020 pela coluna 'ANO' com soma da coluna 'TONELADAS' para obter a quantidade total de resíduos por ano
df_residuos_anual = df_2013_2018.groupby('ANO')['TONELADAS'].sum().reset_index()
df_residuos_anual.rename(columns={'ANO': 'ano', 'TONELADAS': 'total_toneladas'}, inplace=True)

print("\nDados de resíduos agregados anualmente:\n", df_residuos_anual)

# Merge do DataFrame de resíduos anuais com o dataFrame de população anual do estado de São Paulo com base na coluna 'ano'
df_modelagem = pd.merge(df_residuos_anual, df_pop_anual_sp, on='ano', how='inner')
print("\nDataFrame unificado para modelagem:\n", df_modelagem)

"""# Modelagem Preditiva

## Scatter plot da relação entre resíduos e população
"""

plt.figure(figsize=(8, 6))
sns.scatterplot(x='populacao_total', y='total_toneladas', data=df_modelagem)
plt.title('Relação entre População e Geração de Resíduos (SP)')
plt.xlabel('População Total')
plt.ylabel('Total de Toneladas de Resíduos')
plt.grid(True)
plt.show()

"""Este é um scatter plot dos mesmos dados, mas sem a linha de regressão. Ele mostra a dispersão dos pontos, indicando a relação entre as duas variáveis sem a imposição de um modelo linear. Podemos observar uma tendência geral de queda na geração de resíduos conforme a população aumenta ligeiramente ao longo dos anos.

## Tendência da geração de resíduos ao longo do tempo
"""

plt.figure(figsize=(8, 6))
sns.lineplot(x='ano', y='total_toneladas', data=df_modelagem, marker='o')
plt.title('Geração Anual de Resíduos em SP')
plt.xlabel('Ano')
plt.ylabel('Total de Toneladas de Resíduos')
plt.grid(True)
plt.show()

"""Este é um gráfico de linha mostrando a evolução da geração total de resíduos no estado de São Paulo ao longo dos anos de 2013 a 2018.

A linha com marcadores indica uma tendência de queda na geração de resíduos durante esse período, com uma pequena recuperação em 2017 e 2018.

## Tendência da população ao longo do tempo
"""

plt.figure(figsize=(8, 6))
sns.lineplot(x='ano', y='populacao_total', data=df_modelagem, marker='o')
plt.title('População Anual do Estado de SP')
plt.xlabel('Ano')
plt.ylabel('População Total')
plt.grid(True)
plt.show()

"""Este é um gráfico de linha mostrando a evolução da população total do estado de São Paulo ao longo dos anos de 2013 a 2018.

A linha com marcadores indica uma tendência de crescimento da população durante esse período, embora o aumento não seja acentuado.

## Construção e Treinamento do Modelo (Regressão Linear
"""

from sklearn.linear_model import LinearRegression

X = df_modelagem[['populacao_total']]
y = df_modelagem['total_toneladas']

modelo_linear = LinearRegression()
modelo_linear.fit(X, y)

# Coeficientes do modelo
print(f'Intercepto: {modelo_linear.intercept_:.2f}')
print(f'Coeficiente da População: {modelo_linear.coef_[0]:.8f}')

"""**Interpretação dos Dados da Regressão Linear:**

*   Intercepto: 51266760.50

Este é o valor estimado da geração total de resíduos (em toneladas) quando a população total é zero. Em um contexto real, uma população zero é impossível, então o intercepto serve principalmente como um parâmetro do modelo. Ele pode ser interpretado como um ponto de partida teórico da geração de resíduos, desconsiderando a influência da população.

*   Coeficiente da População: -1.99062898

Este coeficiente sugere que, para cada aumento de uma pessoa na população do estado de São Paulo, a geração total de resíduos tende a diminuir em aproximadamente 1.99 toneladas, de acordo com este modelo linear e dentro do período de 2013 a 2018.

## Avaliação do Modelo
"""

from sklearn.metrics import r2_score

y_pred = modelo_linear.predict(X)
r_squared = r2_score(y, y_pred)
print(f'R-quadrado: {r_squared:.4f}')

# Plot dos dados reais vs. a linha de regressão
plt.figure(figsize=(8, 6))
sns.scatterplot(x='populacao_total', y='total_toneladas', data=df_modelagem, label='Dados Reais')
plt.plot(X, y_pred, color='red', label='Regressão Linear')
plt.title('Regressão Linear: População vs. Geração de Resíduos (SP)')
plt.xlabel('População Total')
plt.ylabel('Total de Toneladas de Resíduos')
plt.legend()
plt.grid(True)
plt.show()

"""Este é um scatter plot mostrando a relação entre a população total do estado de São Paulo (eixo x) e o total de toneladas de resíduos gerados no estado (eixo y) para os anos de 2013 a 2018.

A linha vermelha representa a linha de regressão linear ajustada aos dados. Ela tenta capturar a tendência linear entre as duas variáveis.

O valor de R-quadrado (0.6602) indica a proporção da variância na geração de resíduos que é explicada pela variação na população. Um valor de 0.6602 sugere que aproximadamente 66% da variação na geração de resíduos pode ser explicada pela população, dentro do período analisado.

# Resultados

Os gráficos mostram uma leve tendência de aumento na população e uma tendência de queda na geração de resíduos no estado de São Paulo entre 2013 e 2018.

O modelo de regressão linear ajustado aos dados sugere uma relação negativa entre a população e a geração de resíduos nesse período. O coeficiente negativo indica que, conforme a população aumentou ligeiramente, a geração de resíduos tendeu a diminuir.

O R-quadrado de 0.6602 indica que o modelo linear explica uma parte considerável da variabilidade na geração de resíduos com base na população, mas ainda há outros fatores em jogo que não estão sendo capturados por este modelo.

Mesmo que o modelo mostre uma relação estatística, isso não significa que o aumento da população causou a diminuição dos resíduos. Outros fatores (como mudanças em hábitos de consumo, políticas de reciclagem mais eficazes, desenvolvimento econômico, etc.) podem estar influenciando essa tendência.

O modelo foi construído com apenas 6 pontos de dados (anos). Uma amostra tão pequena pode levar a resultados que não são representativos de tendências de longo prazo ou de relações causais reais. O modelo pode ser sensível a valores atípicos ou a características específicas desse período.
"""